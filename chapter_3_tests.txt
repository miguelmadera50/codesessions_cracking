Chapter 3 - Stacks and Queues
// Stack and Queue classes as provided by Cracking book
class Stack {
    static class StackNode {
        int data;
        StackNode next;

        StackNode(int data) {
            this.data = data;
        }
    }

    private StackNode top;

    public int pop() {
        if (top == null) throw new EmptyStackException();
        int item = top.data;
        top = top.next;
        return item;
    }

    public void push (int item) {
        StackNode t = new StackNode(item);
        t.next = top;
        top = t;
    }

    public int peek() {
        if (top == null) throw new EmptyStackException();
        return top.data;
    }

    public boolean isEmpty() {
        return top == null;
    }
}


class Queue {
    static class QueueNode {
        int data;
        QueueNode next;

        QueueNode(int data) {
            this.data = data;
        }
    }

    private QueueNode first;
    private QueueNode last;

    public void add (int item) {
        QueueNode t = new QueueNode(item);
        if (last != null) last.next = t;
        last = t;

        if (first == null) first = last;
    }

    public int remove() {
        if (first == null) throw new NoSuchElementException();
        int data = first.data;
        first = first.next;
        if (first == null) last = null;
        return data;
    }

    public int peek() {
        if (first == null) throw new NoSuchElementException();
        return first.data;
    }

    public boolean isEmpty() {
        return first == null;
    }
}


3.1
// Three in one: Describe how you could use a single array to implement three stacks.
---------- Test Procedure ---------
    Each stack should have -> pop()
    Each stack should have -> push()
    Each stack should have -> peek()
    Each stack should have -> isEmpty()

isEmpty on stack 1 -> true
isEmpty on stack 2 -> true
isEmpty on stack 3 -> true

push to stack 1 - '1'
push to stack 1 - '2'
push to stack 2 - '3'
push to stack 3 - '4'
push to stack 3 - '5'
push to stack 2 - '6'
push to stack 1 - '7'
push to stack 3 - '8'

isEmpty on stack 1 -> false                 // 0 - 1, 2, 7
isEmpty on stack 2 -> false                 // 1 - 3, 6
isEmpty on stack 3 -> false                 // 2 - 4, 5, 8

pop stack 1 -> 7
pop stack 2 -> 6
pop stack 3 -> 8
pop stack 3 -> 5
pop stack 2 -> 3
pop stack 1 -> 2

isEmpty on stack 1 -> false
isEmpty on stack 2 -> true
isEmpty on stack 3 -> false


3.2
// Stack Min: How would you design a stack which, in addition to push and pop, has a function min which returns
// the minimum element? Push pop and min should all operate in O(1) time.
push to stack - 5
check min -> 5

push to stack - 7
check min -> 5

push to stack - 3
check min -> 3

push to stack - 2
check min -> 2

pop from stack -> 2
check min -> 3

pop from stack -> 3
check min -> 5


3.3
// Stack of Plates: Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore,
// in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a
// data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks and should
// create a new stack once the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks.pop() should
// behave identically to a single stack. Follow up implement a function popAt(index) which performs a pop
// operation on a specific sub-stack.
set threshold - 3

push to stack - 1
push to stack - 2
push to stack - 3

push to stack - 4
push to stack - 5
push to stack - 6

push to stack - 7
push to stack - 8
push to stack - 9

popAt from stack 1 -> 6
popAt from stack 1 -> 5
popAt from stack 1 -> 4
popAt from stack 1 -> EXCEPTION

pop from stack -> 9
pop from stack -> 8

popAt from stack 0 -> 3
popAt from stack 0 -> 2

pop from stack -> 7
pop from stack -> 1
pop from stack -> EXCEPTION


3.4
// Queue via stacks: Implement a MyQueue class which implements a queue using two stacks.
check isEmpty -> true
queue add - 1
queue add - 2
queue add - 3

queue remove -> 1
queue remove -> 2
check isEmpty -> false

queue add - 4
queue add - 5

queue remove -> 3
queue remove -> 4
queue remove -> 5

queue remove -> EXCEPTION
check isEmpty -> true


3.5
// Sort Stack: Write a program to sort a stack such that the smallest items are on the current_top. You can use an
// additional temporary stack, but you may not copy the elements into any other data structure. The stack
// supports the following operations: push, pop, peek, isEmpty.


3.6
// Animal Shelter: An animal shelter, which holds only dogs and cats, operates on a strictly first in first out
// basis. People must adopt either the oldest (based on a arrival time) of all the animals in the shelter, or
// they can select whether the prefer a dog or a cat. The cannot select which specific animal the would like.
// Create the data structures to maintain the system and implement operations such as add, dequeueAny,
// dequeueDog, dequeueCat. You may use a built-in LinkedList data structure.
queue add - dog(1)
queue add - dog(2)
queue add - cat(3)
queue add - cat(4)

dequeue cat -> 3
dequeue dog -> 1
dequeue any -> 2

queue add - dog(5)
queue add - cat(6)
queue add - dog(7)

dequeue cat -> 4
dequeue cat -> 6
dequeue cat -> EXCEPTION

dequeue any -> 5
dequeue any -> 7
dequeue any -> EXCEPTION

